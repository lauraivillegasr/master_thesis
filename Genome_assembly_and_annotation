### **GENOME ASSEMBLY - using long reads**


1. Checking kmer spectra of the raw reads using different tools

- BBmap

```bbmap/kmercountexact.sh qin=33 k=27 in=HiFi_reads/PS1146/m54274Ue_211112_020939.hifi_reads.fastq.gz khist=PS1146_bbmaphistk27.txt peaks=PS1146_bbmaopeaks27.txt -Xmx3600M```

- KAT - K-mer Analysis Toolkit

```kat hist -o ES5_kat227 HiFi_reads/ES5/m54274Ue_211114_223525.hifi_reads.fastq.gz```

2. Genome size estimaton

Can be obtained from the header of the output file from bbmap
Can be obtained from log file of KAT --> was the most accurate one compared to previous reports on the genus
Can be obtained using the espectra obtained from KAT using tools like Genomescope (online http://qb.cshl.edu/genomescope/) and findGSE (R based)

Command on R using findGSE: ```findGSE(histo="PS1146_kat31", sizek=27, outdir="PS1146_27mer")```

3. Assembly 

3.1. Flye

```flye --pacbio-hifi HiFi_reads/PS1146/m54274Ue_211112_020939.hifi_reads.fastq.gz --out-dir HiFi_reads/PS1146/ --threads 8```

3.2. Hifiasm

```./hifiasm/hifiasm -o PS1146_hifiasm -t 8 HiFi_reads/PS1146/m54274Ue_211112_020939.hifi_reads.fastq.gz```

3.3. Wtdbg2

```wtdbg2 -t 8 -x ccs -g 300m -fo PS1146_redbean -i HiFi_reads/PS1146/m54274Ue_211112_020939.hifi_reads.fastq.g```

```wtpoa-cns -t 16 -i PS1146_redbean.ctg.lay.gz -fo PS1146_redbean.raw.fa```

```minimap2 -t16 -ax map-pb -r2k PS1146_redbean.raw.fa HiFi_reads/PS1146/m54274Ue_211112_020939.hifi_reads.fastq.gz | samtools sort -@4 >PS1146_redbean.bam```

```samtools view -F0x900 PS1146_redbean.bam | wtpoa-cns -t 16 -d PS1146_redbean.raw.fa -i - -fo PS1146_readbean.cns.fa```

3.4. Canu - for Hifi reads


```./canu/build/bin/canu -p HiFi_reads/PS1146/PS1146_canu genomeSize=500m -d HiFi_reads/ -maxThreads=16 -maxMemory=120g -pacbio-hifi useGrid=false HiFi_reads/PS1146/m54274Ue_211112_020939.hifi_reads.fastq.gz```

4. Assesing the quality of the assemblies

- GVolante

Used to obtain busco completeness (BUSCO V4), obtain N50 and check for duplications (https://gvolante.riken.jp). Based on these common metrics, the "best" assembly was selected for the following steps.

5. Checking for coverage and contaminations using blobtoolkit

- Some notes on how to install it on CHEOPS: 

	module purge
	module load miniconda
	eval "$(conda shell.bash hook)"


Use Conda to install remaining dependencies: 

	conda create -n btk_env -c conda-forge -y python=3.6 docopt psutil pyyaml ujson tqdm nodejs=10 yq;
	conda activate btk_env;
	conda install -c bioconda -y pysam seqtk;
	conda install -c conda-forge -y geckodriver selenium pyvirtualdisplay;
	pip install fastjsonschema;
	mkdir -p ~/blobtoolkit;
	cd ~/blobtoolkit;
	git clone https://github.com/blobtoolkit/blobtools2;
	git clone https://github.com/blobtoolkit/viewer;
	git clone https://github.com/blobtoolkit/specification;
	git clone https://github.com/blobtoolkit/insdc-pipeline;
	cd viewer;
	npm install;
	cd ..;

inside the btk_env environment in the folder /blobtoolkit/viewer:

```npm audit fix```

and then inside blobtoolkit/blobtools2: 

```do pip install -r requirements.txt --ignore-installed certifi```


- Creating a data base adding coverage, hits and BUSCO completness results (all steps are done after activating the conda environment btk_env)

* Creating the database

```./blobtoolkit/blobtools2/blobtools create --fasta ES5_hifiasm/ES5_primary_contigs_hifiasm.fa ES5_hifiasm/Dataset_blob/```

* Adding BUSCO results

```./blobtoolkit/blobtools2/blobtools add --busco blobtools_info/ES5_hifiasm.busco.nematoda_odb10.tsv blobtools_info/ES5_hifiasm```

While running add busco, the .tsv file is the one obtained while running busco on gvolante. It requires bit of manual editing, like changing the contigs names so they match that of the assembly and removing missing genes so all contigs match the identifiers defined while creating the database.

* Running blast to obtain hits that will be added to the database

		blastn -db blobtools_info/nt/nt \
       	-query ES5_hifiasm/ES5_primary_contigs_hifiasm.fa \
       	-outfmt '6 qseqid staxids bitscore std' \
       	-max_target_seqs 10 \
       	-max_hsps 1 \
       	-evalue 1e-25 \
       	-num_threads 32 \
       	-out ES5_hifiasm.ncbi.blastn.out

* Running minimap2 to obtain a mapping of the reads against the assembly and check coverage

		minimap2 -ax map-hifi \
        	 -t 32 ES5_hifiasm/ES5_primary_contigs_hifiasm.fa \
        	 HiFi_reads/ES5/m54274Ue_211114_223525.hifi_reads.fastq.gz \
		| samtools sort -@32 -O BAM -o ES5_hifiasm.mapped.bam -

* Adding all the generated files to the databse


		./blobtoolkit/blobtools2/blobtools add --taxrule bestsumorder \
		--taxdump /blobtools_info/taxdump/ \
		--cov filtered_ES5_hifiasm.mapped.bam \
		--hits filtered_ES5_hifiasm.ncbi.blastn.out \
		Dataset_blob

* Visualizing results (not done on cheops - motoko)

```./blobtoolkit/blobtools2/blobtools view --remote Dataset_blob``` 


* Filtering assembly and raw reads according to taxa that has highly different GC content or is bacteria we would expect as contamination from the media

```./blobtoolkit/blobtools2/blobtools filter --param bestsumorder_phylum--Keys=Proteobacteria,Bacteroidetes,Actinobacteria,Chordata,Uroviricota --fastq HiFi_reads/ES5/m54274Ue_211114_223525.hifi_reads.fastq.gz  —cov ES5_hifiasm/ES5_hifiasm.mapped.bam ES5_hifiasm/Dataset_blob```


6. Purging assembly to purge duplicates in the assembly that migth be the result of highly heterozygous regions and not really duplications (purge_dups was installed using conda) 

	conda activate minimap_purge
	pri_asm=2filtered_ES5_hifiasm.fasta
	for i in $(cat pb.fofn)
	do
	minimap2 -xasm20 $pri_asm $i | gzip -c - > $i.paf.gz
	done
	pbcstat *.paf.gz
	calcuts PB.stat > cutoffs 2>calcults.log
	split_fa $pri_asm > $pri_asm.split
	minimap2 -xasm5 -DP $pri_asm.split $pri_asm.split | gzip -c - > $pri_asm.split.self.paf.gz
	purge_dups -2 -T cutoffs -c PB.base.cov $pri_asm.split.self.paf.gz > dups.bed 2> purge_dups.log
	get_seqs -e dups.bed $pri_asm
	

All following steps are performed on the resulting purged assembly without the contaminant reads. 

7. Gene annotation

7.1. Repeat masking - loaded modules on cheops repeat omdeler and repeatmasker

	BuildDatabase -name ES5_gene_DB 2filtered_ES5_hifiasm.purged.fa
	RepeatModeler -pa 24 -database ES5_gene_DB
	RepeatClassifier -consensi ES5_gene_DB-families.fa
	RepeatMasker -pa 16 -e ncbi -lib ES5_gene_DB-families.fa 2filtered_ES5_hifiasm.purged.fa

7.2. Alignment

For ES5, where RNA-seq was available on the SRR data base, alignment of reads against reference genome wa sperformed using gsnap

```gmap_build -D es5_annotation/ -d genome_index 2filtered_ES5_hifiasm.purged.fa.masked```

```gsnap -t 4 -D es5_annotation/ -d genome_index -A sam -o es5_annotation/ES5-rnaseq.mapped.gsnap.sam ES5_r1.fq ES5_r2.fq```

7.3. Prediction and annotation
For PS1146 using augustus

```augustus --species=caenorhabditis 2filtered_PS1146_hifiasm.purged.fa.masked  > annotation_trial_PS1146.gff```

For ES5 using braker2
```braker.pl --species=ES5 --AUGUSTUS_CONFIG_PATH=/scratch/lvilleg1/augustus_config/ --genome=2filtered_ES5_hifiasm.purged.fa.masked --bam=es5_annotation/ES5_RNA_seq_gsnap.mapped.sort.bam```

7.4. Running BUSCO on gVolante for resulting coding sequences.

7.5. Extracting statistics from annotation (from gff/gtf files)

Extracting general stats (number of genes, exons and introns, number of coding sequences, start codons and stop codons) as well as length distribution

```gt gff3 -sort -tidy PS1146_augustus.gtf | gt stat -genelengthdistri -o PS1146_genelengthdist.txt```

Here, the code only for gene length is shown, exon and intron length were also estimated using the flags ```-exonlengthdistri```and ```-intornlengthdistri```




